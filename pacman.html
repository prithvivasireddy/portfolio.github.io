<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man - Prithvi Vasireddy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000000;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: 'VT323', monospace;
            color: #00ff00;
        }
        canvas {
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
            image-rendering: pixelated;
        }
        .game-container {
            text-align: center;
        }
        h1 {
            font-size: 48px;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
            margin-bottom: 10px;
        }
        p {
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }
        button {
            background-color: #000000;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'VT323', monospace;
            font-size: 28px;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        button:hover {
            background-color: #00ff00;
            color: #000000;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }
        .scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.15) 1px, transparent 1px, transparent 2px);
            pointer-events: none;
            z-index: 1;
            animation: scanline-move 4s linear infinite;
        }
        @keyframes scanline-move {
            0% { background-position: 0 0; }
            100% { background-position: 0 4px; }
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <div class="game-container">
        <h1>Pac-Man</h1>
        <p id="instructions">Use ←↑→↓ to move. Eat all dots to win! Press S to start.</p>
        <div id="game"></div>
        <button onclick="window.location.href='index.html'" style="margin-top: 20px;">Back to Home</button>
    </div>
    <script>
        let pacman, ghosts, dots;
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let gameStarted = false;
        let cellSize = 20;
        let rows = 21;
        let cols = 28;
        let maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1],
            [1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
            [1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1],
            [1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],
            [1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Simulate chomp sound using JavaScript Audio API
        function playChompSound() {
            const audio = new Audio('https://www.soundjay.com/buttons/beep-01a.mp3');
            audio.play().catch(err => console.log('Audio error:', err));
        }

        function setup() {
            let canvasSize = min(windowWidth * 0.9, windowHeight * 0.7);
            cellSize = floor(canvasSize / max(cols, rows));
            let canvas = createCanvas(cols * cellSize, rows * cellSize);
            canvas.parent('game');
            pixelDensity(1);
            textFont('VT323');
            textSize(cellSize);
            textAlign(LEFT);
            resetGame();
        }

        function resetGame() {
            pacman = new PacMan(1, 1);
            ghosts = [
                new Ghost(13, 10, color(255, 0, 0)), // Red ghost
                new Ghost(14, 10, color(255, 105, 180)), // Pink ghost
                new Ghost(13, 11, color(0, 255, 255)), // Cyan ghost
                new Ghost(14, 11, color(255, 165, 0)) // Orange ghost
            ];
            dots = [];
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (maze[i][j] === 0) {
                        dots.push(new Dot(j, i));
                    }
                }
            }
            score = 0;
            lives = 3;
            gameOver = false;
            gameStarted = false;
            loop();
        }

        function draw() {
            // Starry background
            background(0);
            for (let i = 0; i < 50; i++) {
                fill(255, 255, 255, random(100, 200));
                ellipse(random(width), random(height), 2, 2);
            }

            if (!gameStarted) {
                textAlign(CENTER);
                textSize(cellSize * 2);
                fill(0, 255, 0);
                text('PAC-MAN', width / 2, height / 2 - cellSize);
                textSize(cellSize);
                text('Press S to Start', width / 2, height / 2 + cellSize);
                text('←↑→↓ to Move', width / 2, height / 2 + cellSize * 2);
                return;
            }

            // Draw maze
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (maze[i][j] === 1) {
                        fill(0, 0, 255);
                        noStroke();
                        rect(j * cellSize, i * cellSize, cellSize, cellSize, cellSize / 5);
                    }
                }
            }

            // Draw HUD
            fill(0, 255, 0);
            text(`Score: ${score}`, 10, cellSize);
            for (let i = 0; i < lives; i++) {
                ellipse((i + 1) * cellSize * 1.5, cellSize * 2, cellSize);
            }

            // Draw dots
            for (let dot of dots) {
                dot.show();
                if (pacman.hits(dot)) {
                    dot.active = false;
                    score += 10;
                    playChompSound();
                }
            }
            dots = dots.filter(d => d.active);

            // Draw Pac-Man and ghosts
            pacman.show();
            if (gameStarted) pacman.move();

            for (let ghost of ghosts) {
                ghost.show();
                if (gameStarted) ghost.move();
                if (pacman.hits(ghost)) {
                    lives--;
                    if (lives <= 0) {
                        gameOver = true;
                    } else {
                        pacman = new PacMan(1, 1);
                        ghosts.forEach(g => g.reset());
                    }
                }
            }

            // Game over or win
            if (gameOver) {
                textAlign(CENTER);
                textSize(cellSize * 2);
                fill(0, 255, 0, 255 * (sin(frameCount * 0.05) + 1) / 2);
                text('Game Over', width / 2, height / 2);
                textSize(cellSize);
                text('Press R to Restart', width / 2, height / 2 + cellSize * 2);
                noLoop();
            } else if (dots.length === 0) {
                textAlign(CENTER);
                textSize(cellSize * 2);
                fill(0, 255, 0, 255 * (sin(frameCount * 0.05) + 1) / 2);
                text('You Win!', width / 2, height / 2);
                textSize(cellSize);
                text('Press R to Restart', width / 2, height / 2 + cellSize * 2);
                noLoop();
            }
        }

        function keyPressed() {
            if (key === 's' && !gameStarted) {
                gameStarted = true;
                loop();
            }
            if (keyCode === LEFT_ARROW) pacman.setDir(-1, 0);
            if (keyCode === RIGHT_ARROW) pacman.setDir(1, 0);
            if (keyCode === UP_ARROW) pacman.setDir(0, -1);
            if (keyCode === DOWN_ARROW) pacman.setDir(0, 1);
            if (key === 'r' && (gameOver || dots.length === 0)) {
                resetGame();
            }
        }

        class PacMan {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.r = cellSize / 2;
                this.dirX = 0;
                this.dirY = 0;
                this.speed = 2;
                this.angle = 0;
            }
            show() {
                let mouthAngle = 0.2 * sin(frameCount * 0.2) + 0.4;
                fill(255, 255, 0);
                noStroke();
                push();
                translate((this.x + 0.5) * cellSize, (this.y + 0.5) * cellSize);
                if (this.dirX === 1) rotate(0);
                else if (this.dirX === -1) rotate(PI);
                else if (this.dirY === -1) rotate(-PI / 2);
                else if (this.dirY === 1) rotate(PI / 2);
                arc(0, 0, this.r * 2, this.r * 2, mouthAngle, TWO_PI - mouthAngle);
                pop();
            }
            move() {
                let nextX = this.x + this.dirX * this.speed / cellSize;
                let nextY = this.y + this.dirY * this.speed / cellSize;
                if (!this.collides(nextX, nextY)) {
                    this.x = nextX;
                    this.y = nextY;
                }
                this.x = constrain(this.x, 0, cols - 1);
                this.y = constrain(this.y, 0, rows - 1);
            }
            setDir(dx, dy) {
                let nextX = this.x + dx * this.speed / cellSize;
                let nextY = this.y + dy * this.speed / cellSize;
                if (!this.collides(nextX, nextY)) {
                    this.dirX = dx;
                    this.dirY = dy;
                }
            }
            collides(x, y) {
                let i = floor(y);
                let j = floor(x);
                if (i < 0 || i >= rows || j < 0 || j >= cols) return true;
                return maze[i][j] === 1;
            }
            hits(obj) {
                let d = dist((this.x + 0.5) * cellSize, (this.y + 0.5) * cellSize, (obj.x + 0.5) * cellSize, (obj.y + 0.5) * cellSize);
                return d < this.r + obj.r;
            }
        }

        class Ghost {
            constructor(x, y, c) {
                this.x = x;
                this.y = y;
                this.r = cellSize / 2;
                this.color = c;
                this.speed = 1.5;
                this.dir = random(['up', 'down', 'left', 'right']);
                this.startX = x;
                this.startY = y;
            }
            show() {
                fill(this.color);
                noStroke();
                push();
                translate((this.x + 0.5) * cellSize, (this.y + 0.5) * cellSize);
                let offset = cellSize * 0.1 * sin(frameCount * 0.1);
                beginShape();
                vertex(-this.r, -this.r + offset);
                vertex(this.r, -this.r + offset);
                vertex(this.r, this.r - cellSize / 4);
                vertex(this.r - cellSize / 4, this.r);
                vertex(0, this.r + cellSize / 4);
                vertex(-this.r + cellSize / 4, this.r);
                vertex(-this.r, this.r - cellSize / 4);
                endShape(CLOSE);
                fill(255);
                ellipse(-this.r / 2, -this.r / 2 + offset, this.r / 2);
                ellipse(this.r / 2, -this.r / 2 + offset, this.r / 2);
                pop();
            }
            move() {
                let directions = ['up', 'down', 'left', 'right'];
                let nextX = this.x;
                let nextY = this.y;
                if (frameCount % 60 === 0) {
                    this.dir = random(directions);
                }
                if (this.dir === 'up') nextY -= this.speed / cellSize;
                if (this.dir === 'down') nextY += this.speed / cellSize;
                if (this.dir === 'left') nextX -= this.speed / cellSize;
                if (this.dir === 'right') nextX += this.speed / cellSize;
                if (!this.collides(nextX, nextY)) {
                    this.x = nextX;
                    this.y = nextY;
                } else {
                    this.dir = random(directions);
                }
                this.x = constrain(this.x, 0, cols - 1);
                this.y = constrain(this.y, 0, rows - 1);
            }
            collides(x, y) {
                let i = floor(y);
                let j = floor(x);
                if (i < 0 || i >= rows || j < 0 || j >= cols) return true;
                return maze[i][j] === 1;
            }
            reset() {
                this.x = this.startX;
                this.y = this.startY;
                this.dir = random(['up', 'down', 'left', 'right']);
            }
        }

        class Dot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.r = cellSize / 4;
                this.active = true;
            }
            show() {
                if (this.active) {
                    fill(255, 255, 0);
                    noStroke();
                    ellipse((this.x + 0.5) * cellSize, (this.y + 0.5) * cellSize, this.r * 2);
                }
            }
        }
    </script>
</body>
</html>
